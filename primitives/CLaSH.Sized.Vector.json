[ { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.eq#"
    , "templateE" : "~ARG[0] = ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.neq#"
    , "templateE" : "~ARG[0] /= ~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.head"
    , "templateD" :
"~SYM[0]_head : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= ~SYM[1](0);
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.tail"
    , "templateD" :
"~SYM[0]_tail : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= ~SYM[1](1 to ~SYM[1]'high);
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.last"
    , "templateD" :
"~SYM[0]_last : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= ~SYM[1](~SYM[1]'high);
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.init"
    , "templateD" :
"~SYM[0]_init : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];
  ~RESULT <= ~SYM[1](0 to ~SYM[1]'high - 1);
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.take"
    , "comment"   :
    "take :: SNat m         -- ARG[0]
          -> Vec (m + n) a  -- ARG[1]
          -> Vec m a"
    , "templateD" :
"~SYM[0]_take : block
  signal ~SYM[1] : ~TYP[1];
begin
  ~SYM[1] <= ~ARG[1];

  ~SYM[2]_takeZ : if ~RESULT'length = 0 generate
    ~RESULT <= ~ERRORO;
  end generate;

  ~SYM[3]_takeSN : if ~RESULT'length /= 0 generate
    ~RESULT <= ~SYM[1](0 to ~RESULT'high);
  end generate;
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.drop"
    , "comment"   :
    "drop :: SNat m         -- ARG[0]
          -> Vec (m + n) a  -- ARG[1]
          -> Vec n a"
    , "templateD" :
"~SYM[0]_drop : block
  signal ~SYM[1] : ~TYP[1];
begin
  ~SYM[1] <= ~ARG[1];

  ~SYM[2]_dropZ : if ~RESULT'length = 0 generate
    ~RESULT <= ~ERRORO;
  end generate;

  ~SYM[3]_dropSN : if ~RESULT'length /= 0 generate
    ~RESULT <= ~SYM[1](~LIT[0] to SYM[1]'high);
  end generate;
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.exact"
    , "templateD" :
"~SYM[0]_exact : block
  signal ~SYM[1] : ~TYP[1];
begin
  ~SYM[1] <= ~ARG[1];
  ~RESULT <= ~SYM[1](~LIT[0]);
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.select"
    , "comment"   :
    "select :: (CmpNat (i + s) (s * n) ~ GT) -- ARG[0]
            => SNat f                        -- ARG[1]
            -> SNat s                        -- ARG[2]
            -> SNat n                        -- ARG[3]
            -> Vec i a                       -- ARG[4]
            -> Vec n a"
    , "templateD" :
"~SYM[0]_select : block
  signal ~SYM[1] : ~TYP[4];
begin
  ~SYM[1] <= ~ARG[4];

  ~SYM[2]_selectZ : if ~RESULT'length = 0 generate
    ~RESULT <= ~ERRORO;
  end generate;

  ~SYM[3]_selectSN : if ~RESULT'length /= 0 generate
    ~SYM[4]_selectIter : for ~SYM[5] in ~RESULT'range generate
    begin
      ~RESULT(~SYM[5]) <= ~SYM[1](~LIT[1]+(~LIT[2]*~SYM[5]));
    end generate;
  end generate;
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.++"
    , "templateD" : "~RESULT <= ~TYPM[0]'(~ARG[0]) & ~TYPM[1]'(~ARG[1]);"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.concat"
    , "templateD" :
"~SYM[0]_concat : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];

  ~SYM[2]_concatZ : if ~RESULT'length = 0 generate
    ~RESULT <= ~ERRORO;
  end generate;

  ~SYM[3]_concatSN : if ~RESULT'length /= 0 generate
    ~SYM[4]_concatIter : for ~SYM[5] in ~SYM[1]'range generate
    begin
      ~RESULT((~SYM[5] * ~SYM[1](0)'length) to ((~SYM[5] * ~SYM[1](0)'length) + ~SYM[1](0)'high)) <= ~SYM[1](~SYM[5]);
    end generate;
  end generate;
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.splitAt"
    , "templateD" :
"~SYM[0]_splitAt : block
  signal ~SYM[1] : ~TYP[1];
begin
  ~SYM[1] <= ~ARG[1];
  ~RESULT <= (~SYM[1](0 to ~LIT[0]-1),~SYM[1](~LIT[0] to ~SYM[1]'high));
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.unconcat"
    , "comment"   :
    "unconcat :: KnownNat n     -- ARG[0]
              => SNat m         -- ARG[1]
              -> Vec (n * m) a  -- ARG[2]
              -> Vec n (Vec m a)"
    , "templateD" :
"~SYM[0]_unconcat : block
  signal ~SYM[1] : ~TYP[2];
begin
  ~SYM[1] <= ~ARG[2];

  ~SYM[2]_unconcatZ : if ~SYM[1]'length = 0 generate
    ~RESULT <= ~ERRORO;
  end generate;

  ~SYM[3]_unconcatSN : if ~SYM[1]'length /= 0 generate
    ~SYM[4]_unconcatIter : for ~SYM[5] in ~RESULT'range generate
    begin
      ~RESULT(~SYM[5]) <= ~SYM[1]((~SYM[5] * ~LIT[1]) to ((~SYM[5] * ~LIT[1]) + ~LIT[1] - 1));
    end generate;
  end generate;
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.merge"
    , "templateD" :
"~SYM[0]_merge : block
  signal ~SYM[1] : ~TYP[0];
  signal ~SYM[2] : ~TYP[1];
begin
  ~SYM[1] <= ~ARG[0];
  ~SYM[2] <= ~ARG[1];

  ~SYM[3]_mergeZ : if ~RESULT'length = 0 generate
    ~RESULT <= ~ERRORO;
  end generate;

  ~SYM[4]_mergeSN : if ~RESULT'length /= 0 generate
    ~SYM[5]_mergeIter : for ~SYM[6] in ~SYM[1]'range generate
    begin
      ~RESULT(2*~SYM[6])   <= ~SYM[1](~SYM[6]);
      ~RESULT(2*~SYM[6]+1) <= ~SYM[2](~SYM[6]);
    end generate;
  end generate;
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.map"
    , "templateD" :
"~SYM[0]_map : block
  signal ~SYM[1] : ~TYP[1];
begin
  ~SYM[1] <= ~ARG[1];

  ~SYM[2]_mapZ : if ~RESULT'length = 0 generate
    ~RESULT <= ~ERRORO;
  end generate;

  ~SYM[3]_mapSN : if ~RESULT'length /= 0 generate
    ~SYM[4]_mapIter : for ~SYM[5] in ~RESULT'range generate
    begin
      ~INST 0
        ~OUTPUT <= ~RESULT(~SYM[5])~ ~TYPEL[~TYPO]~
        ~INPUT  <= ~SYM[1](~SYM[5])~ ~TYPEL[~TYP[1]]~
      ~INST
    end generate;
  end generate;
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.zipWith"
    , "templateD" :
"~SYM[0]_zipWith : block
  signal ~SYM[1] : ~TYP[1];
  signal ~SYM[2] : ~TYP[2];
begin
  ~SYM[1] <= ~ARG[1];
  ~SYM[2] <= ~ARG[2];

  ~SYM[3]_zipWithZ : if ~RESULT'length = 0 generate
    ~RESULT <= ~ERRORO;
  end generate;

  ~SYM[4]_zipWithSN : if ~RESULT'length /= 0 generate
    ~SYM[5]_zipWithIter : for ~SYM[6] in ~RESULT'range generate
    begin
      ~INST 0
        ~OUTPUT <= ~RESULT(~SYM[6])~ ~TYPEL[~TYPO]~
        ~INPUT  <= ~SYM[1](~SYM[6])~ ~TYPEL[~TYP[1]]~
        ~INPUT  <= ~SYM[2](~SYM[6])~ ~TYPEL[~TYP[2]]~
      ~INST
    end generate;
  end generate;
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.foldr"
    , "templateD" :
"~SYM[0]_foldr : block
  type   ~SYM[1] is array (integer range <>) of ~TYP[1];
  signal ~SYM[2] : ~TYP[2];
  signal ~SYM[3] : ~SYM[1](0 to ~SYM[2]'length);
begin
  ~SYM[2] <= ~ARG[2];

  ~SYM[4]_foldrIter : for ~SYM[5] in ~SYM[3]'range generate
  begin
    ~SYM[6]_foldrZ : if ~SYM[5] = ~SYM[3]'high generate
      ~INST 0
        ~SYM[3](~SYM[5]) <= ~ARG[1];
      ~INST
    end generate;

    ~SYM[7]_foldrSN : if ~SYM[5] /= ~SYM[3]'high generate
      ~INST 0
        ~OUTPUT <= ~SYM[3](~SYM[5])~ ~TYP[1]~
        ~INPUT  <= ~SYM[2](~SYM[5])~ ~TYPEL[~TYP[2]]~
        ~INPUT  <= ~SYM[3](~SYM[5]+1)~ ~TYP[1]~
      ~INST
    end generate;
  end generate;

  ~RESULT <= ~SYM[3](0);
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.foldl"
    , "templateD" :
"~SYM[0]_foldl : block
  type   ~SYM[1] is array (integer range <>) of ~TYP[1];
  signal ~SYM[2] : ~TYP[2];
  signal ~SYM[3] : ~SYM[1](0 to ~SYM[2]'length);
begin
  ~SYM[2] <= ~ARG[2];

  ~SYM[4]_foldlIter : for ~SYM[5] in ~SYM[3]'range generate
  begin
    ~SYM[6]_foldlZ : if ~SYM[5] = 0 generate
      ~SYM[3](~SYM[5]) <= ~ARG[1];
    end generate;

    ~SYM[7]_foldlSN : if ~SYM[5] /= 0 generate
      ~INST 0
        ~OUTPUT <= ~SYM[3](~SYM[5])~ ~TYP[1]~
        ~INPUT  <= ~SYM[3](~SYM[5]-1)~ ~TYP[1]~
        ~INPUT  <= ~SYM[2](~SYM[5]-1)~ ~TYPEL[~TYP[2]]~
      ~INST
    end generate;
  end generate;

  ~RESULT <= ~SYM[3](~SYM[3]'high);
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.index_integer"
    , "templateD" :
"~SYM[0]_index_integer : block
  signal ~SYM[1] : ~TYP[1];
  signal ~SYM[2] : ~TYP[2];
begin
  ~SYM[1] <= ~ARG[1];
  ~SYM[2] <= ~ARG[2];
  -- pragma translate_off
  process (~SYM[1],~SYM[2])
  begin
    if ~SYM[2] < ~SYM[1]'low or ~SYM[2] > ~SYM[1]'high then
      assert false report (\"Index: \" & integer'image(~SYM[2]) & \", is out of bounds: \" & integer'image(~SYM[1]'low) & \" to \" & integer'image(~SYM[1]'high)) severity warning;
      ~RESULT <= ~ERRORO;
    else
    -- pragma translate_on
      ~RESULT <= ~SYM[1](~SYM[2]);
    -- pragma translate_off
    end if;
  end process;
  -- pragma translate_on
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.replace_integer"
    , "templateD" :
"~SYM[0]_replace_integer : block
  signal ~SYM[1] : ~TYP[1];
  signal ~SYM[2] : ~TYP[2];
  signal ~SYM[3] : ~TYP[3];
begin
  ~SYM[1] <= ~ARG[1];
  ~SYM[2] <= ~ARG[2];
  ~SYM[3] <= ~ARG[3];
  process(~SYM[1],~SYM[2],~SYM[3])
    variable ~SYM[4] : ~TYP[1];
  begin
    ~SYM[4] := ~SYM[1];
    -- pragma translate_off
    if ~SYM[2] < ~SYM[4]'low or ~SYM[2] > ~SYM[4]'high then
      assert false report (\"Index: \" & integer'image(~SYM[2]) & \", is out of bounds: \" & integer'image(~SYM[1]'low) & \" to \" & integer'image(~SYM[1]'high)) severity warning;
      ~SYM[4] := ~ERROR[1];
    else
      -- pragma translate_on
      ~SYM[4](~SYM[2]) := ~SYM[3];
      -- pragma translate_off
    end if;
    -- pragma translate_on
    ~RESULT <= ~SYM[4];
  end process;
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.maxIndex"
    , "templateE" : "~LIT[0] - 1"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.length"
    , "templateE" : "~LIT[0]"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.replicate"
    , "templateD" : "~RESULT <= ~TYPMO'(others => ~ARG[1]);"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.iterate"
    , "templateD" :
"~SYM[0]_iterate : for ~SYM[1] in ~RESULT'range generate
begin
  ~SYM[2]_iterateZ : if ~SYM[1] = 0 generate
  begin
    ~RESULT(~SYM[1]) <= ~ARG[2];
  end generate;

  ~SYM[3]_iterateSN : if ~SYM[1] /= 0 generate
  begin
    ~INST 0
      ~OUTPUT <= ~RESULT(~SYM[1])~ ~TYPEL[~TYPO]~
      ~INPUT  <= ~RESULT(~SYM[1]-1)~ ~TYPEL[~TYPO]~
    ~INST
  end generate;
end generate;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.reverse"
    , "templateD" :
"~SYM[0]_reverse : block
  signal ~SYM[1] : ~TYP[0];
begin
  ~SYM[1] <= ~ARG[0];

  ~SYM[2]_reverseZ : if ~RESULT'length = 0 generate
    ~RESULT <= ~SYM[1];
  end generate;

  ~SYM[3]_reverseSN : if ~RESULT'length /= 0 generate
    ~SYM[4]_reverseIter : for ~SYM[5] in ~SYM[1]'range generate
      ~RESULT(~SYM[1]'high - ~SYM[5]) <= ~SYM[1](~SYM[5]);
    end generate;
  end generate;
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.lazyV"
    , "templateE" : "~ARG[1]"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.concatBitVector#"
    , "comment"   :
      "concatBitVector# :: KnownNat m
                        => Vec n (BitVector m)
                        -> BitVector (n * m)"
    , "templateD" :
"~SYM[0]_concatBitVector : block
  signal ~SYM[1] : ~TYP[1];
begin
  ~SYM[1] <= ~ARG[1];

  ~SYM[2]_concatBitVectorZ : if ~RESULT'length = 0 generate
    ~RESULT <= ~ERRORO;
  end generate;

  ~SYM[3]_concatBitVectorSN : if RESULT'length /= 0 generate
    ~SYM[4]_concatBitVectorIter : for ~SYM[5] in ~SYM[1]'range generate
      ~RESULT(((~SYM[5] * ~LIT[0]) + ~LIT[0] - 1) downto (~SYM[5] * ~LIT[0])) <= ~SYM[1](~SYM[5]);
    end generate;
  end generate;
end block;"
    }
  }
, { "BlackBox" :
    { "name"      : "CLaSH.Sized.Vector.unconcatBitVector#"
    , "comment"   :
      "unconcatBitVector# :: (KnownNat n, KnownNat m) -- (ARG[0],ARG[1])
                          => BitVector (n * m)
                          -> Vec n (BitVector m)"
    , "templateD" :
"~SYM[0]_unconcatBitVector : block
  signal ~SYM[1] : ~TYP[2];
begin
  ~SYM[1] <= ~ARG[2];

  ~SYM[2]_unconcatBitVectorZ : if ~SYM[1]'length = 0 generate
    ~RESULT <= ~ERRORO;
  end generate;

  ~SYM[3]_unconcatBitVectorSN : if ~SYM[1]'length /= 0 generate
    ~SYM[4]_unconcatBitVectorIter : for ~SYM[5] in ~RESULT'range generate
      ~RESULT(~SYM[5]) <= ~SYM[1](((~SYM[5] * ~LIT[1]) + ~LIT[1] - 1) downto (~SYM[5] * ~LIT[1]));
    end generate;
  end generate;
end block;"
    }
  }
]
